- name: Get information about the cluster
  set_fact:
    api_groups: "{{ lookup('k8s', cluster_info='api_groups') }}"
  when:
  - is_openshift == False
  - is_k8s == False

- name: Determine the cluster type
  set_fact:
    is_openshift: "{{ True if 'route.openshift.io' in api_groups else False }}"
    is_k8s: "{{ False if 'route.openshift.io' in api_groups else True }}"
  when:
  - is_openshift == False
  - is_k8s == False

# Indicate what kind of cluster we are in (OpenShift or Kubernetes).
- debug:
    msg: "CLUSTER TYPE: is_openshift={{ is_openshift }}; is_k8s={{ is_k8s }}"
- fail:
    msg: "Cannot determine what type of cluster we are in"
  when:
  - is_openshift == False
  - is_k8s == False

- name: Determine the Kubernetes version
  set_fact:
    k8s_version: "{{ lookup('k8s', cluster_info='version').kubernetes.gitVersion | regex_replace('^v', '') }}"
  ignore_errors: yes

- name: Determine the OpenShift version
  vars:
    kube_apiserver_cluster_op_raw: "{{ lookup('k8s', api_version='config.openshift.io/v1', kind='ClusterOperator', resource_name='kube-apiserver') | default({}) }}"
    ri_query: "status.versions[?name == 'raw-internal'].version"
  set_fact:
    openshift_version: "{{ kube_apiserver_cluster_op_raw | json_query(ri_query) | join }}"
  when:
  - is_openshift == True

- name: Determine the Istio implementation
  set_fact:
    is_maistra: "{{ True if 'maistra.io' in api_groups else False }}"

- name: Get information about the operator
  community.kubernetes.k8s_info:
    api_version: v1
    kind: Pod
    namespace: "{{ lookup('env', 'POD_NAMESPACE') }}"
    name: "{{ lookup('env', 'POD_NAME') }}"
  register: operator_pod_raw
  ignore_errors: yes
- name: Determine the version of the operator based on the version label
  set_fact:
    operator_version: "{{ operator_pod_raw.resources[0].metadata.labels.version }}"
  when:
  - operator_pod_raw is defined
  - operator_pod_raw.resources[0] is defined
  - operator_pod_raw.resources[0].metadata is defined
  - operator_pod_raw.resources[0].metadata.labels is defined
  - operator_pod_raw.resources[0].metadata.labels.version is defined
- set_fact:
    operator_version: "unknown"
  when:
  - operator_version is not defined
- debug:
    msg: "OPERATOR VERSION: [{{ operator_version }}]"

# Because we are passing through some yaml directly to Kubernetes resources, we have to retain the camelCase keys.
# All CR parameters are converted to snake_case, but the original yaml is found in the special _kiali_io_kiali param.
# We need to copy that original yaml into our vars where appropriate to keep the camelCase.

- name: Get the original CR as-is for the camelCase keys
  set_fact:
    current_cr: "{{ _kiali_io_kiali }}"

- name: Replace snake_case with camelCase in deployment.affinity.node
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment']['affinity'].pop('node') %}
      {{ kiali_vars | combine({'deployment': {'affinity': {'node': current_cr.spec.deployment.affinity.node }}}, recursive=True) }}
  when:
  - kiali_vars.deployment.affinity is defined
  - kiali_vars.deployment.affinity.node is defined
  - kiali_vars.deployment.affinity.node | length > 0

- name: Replace snake_case with camelCase in deployment.affinity.pod
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment']['affinity'].pop('pod') %}
      {{ kiali_vars | combine({'deployment': {'affinity': {'pod': current_cr.spec.deployment.affinity.pod }}}, recursive=True) }}
  when:
  - kiali_vars.deployment.affinity is defined
  - kiali_vars.deployment.affinity.pod is defined
  - kiali_vars.deployment.affinity.pod | length > 0

- name: Replace snake_case with camelCase in deployment.affinity.pod_anti
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment']['affinity'].pop('pod_anti') %}
      {{ kiali_vars | combine({'deployment': {'affinity': {'pod_anti': current_cr.spec.deployment.affinity.pod_anti }}}, recursive=True) }}
  when:
  - kiali_vars.deployment.affinity is defined
  - kiali_vars.deployment.affinity.pod_anti is defined
  - kiali_vars.deployment.affinity.pod_anti | length > 0

- name: Replace snake_case with camelCase in deployment.tolerations
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('tolerations') %}
      {{ kiali_vars | combine({'deployment': {'tolerations': current_cr.spec.deployment.tolerations }}, recursive=True) }}
  when:
  - kiali_vars.deployment.tolerations is defined
  - kiali_vars.deployment.tolerations | length > 0

- name: Replace snake_case with camelCase in deployment.additional_service_yaml
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('additional_service_yaml') %}
      {{ kiali_vars | combine({'deployment': {'additional_service_yaml': current_cr.spec.deployment.additional_service_yaml }}, recursive=True) }}
  when:
  - kiali_vars.deployment.additional_service_yaml is defined
  - kiali_vars.deployment.additional_service_yaml | length > 0

- name: Replace snake_case with camelCase in deployment.resources
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('resources') %}
      {{ kiali_vars | combine({'deployment': {'resources': current_cr.spec.deployment.resources }}, recursive=True) }}
  when:
  - kiali_vars.deployment.resources is defined
  - kiali_vars.deployment.resources | length > 0

- name: Replace snake_case with camelCase in deployment.override_ingress_yaml
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('override_ingress_yaml') %}
      {{ kiali_vars | combine({'deployment': {'override_ingress_yaml': current_cr.spec.deployment.override_ingress_yaml }}, recursive=True) }}
  when:
  - kiali_vars.deployment.override_ingress_yaml is defined
  - kiali_vars.deployment.override_ingress_yaml | length > 0

- name: Replace snake_case with camelCase in deployment.pod_annotations
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('pod_annotations') %}
      {{ kiali_vars | combine({'deployment': {'pod_annotations': current_cr.spec.deployment.pod_annotations }}, recursive=True) }}
  when:
  - kiali_vars.deployment.pod_annotations is defined
  - kiali_vars.deployment.pod_annotations | length > 0

- name: Replace snake_case with camelCase in deployment.service_annotations
  set_fact:
    kiali_vars: |
      {% set a=kiali_vars['deployment'].pop('service_annotations') %}
      {{ kiali_vars | combine({'deployment': {'service_annotations': current_cr.spec.deployment.service_annotations }}, recursive=True) }}
  when:
  - kiali_vars.deployment.service_annotations is defined
  - kiali_vars.deployment.service_annotations | length > 0

- name: Print some debug information
  vars:
    msg: |
        Kiali Variables:
        --------------------------------
        {{ kiali_vars | to_nice_yaml }}
  debug:
    msg: "{{ msg.split('\n') }}"
  tags: test

# We do not want to blindly default to istio-system for some namespaces. If the istio_namespace is not
# provided, assume it is the same namespace where Kiali is being deployed. Set the other istio namespace
# values accordingly.
# We determine the default Istio namespace var first, and the rest will use it for their default as appropriate.

- name: Set default deployment namespace to the same namespace where the CR lives
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'namespace': current_cr.metadata.namespace}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.namespace is not defined or kiali_vars.deployment.namespace == ""

- name: Set default istio namespace
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'istio_namespace': kiali_vars.deployment.namespace}, recursive=True) }}"
  when:
  - kiali_vars.istio_namespace == ""

- name: "Set default istio component namespace: grafana"
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'istio_component_namespaces': {'grafana': kiali_vars.istio_namespace}}, recursive=True) }}"
  when:
  - kiali_vars.istio_component_namespaces.grafana is not defined or kiali_vars.istio_component_namespaces.grafana == ""

- name: "Set default istio component namespace: tracing"
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'istio_component_namespaces': {'tracing': kiali_vars.istio_namespace}}, recursive=True) }}"
  when:
  - kiali_vars.istio_component_namespaces.tracing is not defined or kiali_vars.istio_component_namespaces.tracing == ""

- name: "Set default istio component namespace: istiod - needed for Istio 1.6 and later"
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'istio_component_namespaces': {'istiod': kiali_vars.istio_namespace}}, recursive=True) }}"
  when:
  - kiali_vars.istio_component_namespaces.istiod is not defined or kiali_vars.istio_component_namespaces.istiod == ""

- name: "Set default istio component namespace: prometheus"
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'istio_component_namespaces': {'prometheus': kiali_vars.istio_namespace}}, recursive=True) }}"
  when:
  - kiali_vars.istio_component_namespaces.prometheus is not defined or kiali_vars.istio_component_namespaces.prometheus == ""

- name: Set default Grafana in_cluster_url
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'grafana': {'in_cluster_url': 'http://grafana.' + kiali_vars.istio_component_namespaces.grafana + ':3000'}}}, recursive=True) }}"
  when:
    kiali_vars.external_services.grafana.in_cluster_url == ""

- name: Set default Tracing in_cluster_url for Maistra
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'tracing': {'in_cluster_url': 'http://tracing.' + kiali_vars.istio_component_namespaces.tracing + ':16686'}}}, recursive=True) }}"
  when:
    kiali_vars.external_services.tracing.in_cluster_url == "" and is_maistra

- name: Set default Tracing in_cluster_url
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'tracing': {'in_cluster_url': 'http://tracing.' + kiali_vars.istio_component_namespaces.tracing + '/jaeger'}}}, recursive=True) }}"
  when:
    kiali_vars.external_services.tracing.in_cluster_url == "" and is_maistra == False

- name: Set default Istio service that provides version info (istiod service that was introduced in Istio 1.6)
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'istio': {'url_service_version': 'http://istiod.' + kiali_vars.istio_component_namespaces.istiod + ':15014/version'}}}, recursive=True) }}"
  when:
  - kiali_vars.external_services.istio.url_service_version == ""

- name: Set default Prometheus URL
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'prometheus': {'url': 'http://prometheus.' + kiali_vars.istio_component_namespaces.prometheus + ':9090'}}}, recursive=True) }}"
  when:
  - kiali_vars.external_services.prometheus.url == ""

# Determine some more defaults.

- name: Set default web root based on cluster type
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'server': {'web_root': '/' if is_openshift else '/kiali'}}, recursive=True) }}"
  when:
  - kiali_vars.server.web_root == ""
- name: Make sure web root never ends with a slash
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'server': {'web_root': kiali_vars.server.web_root | regex_replace('\\/$', '')}}, recursive=True) }}"
  when:
  - kiali_vars.server.web_root != "/"
  - kiali_vars.server.web_root is match(".*/$")

- name: Validate web_schema configuration
  fail:
    msg: "Invalid server.web_schema [{{ kiali_vars.server.web_schema }}]! Must be empty, or one of either 'http' or 'https'"
  when:
  - kiali_vars.server.web_schema != ''
  - kiali_vars.server.web_schema != 'https'
  - kiali_vars.server.web_schema != 'http'

- name: Set default identity cert_file based on cluster type
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'identity': {'cert_file': '/kiali-cert/tls.crt' if is_openshift else ''}}, recursive=True) }}"
  when:
  - kiali_vars.identity.cert_file is not defined
- name: Set default identity private_key_file based on cluster type
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'identity': {'private_key_file': '/kiali-cert/tls.key' if is_openshift else ''}}, recursive=True) }}"
  when:
  - kiali_vars.identity.private_key_file is not defined

- name: Default the image name to a known supported image.
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'image_name': supported_kiali_images[kiali_vars.version].image_name}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.image_name == ""
- name: Default the image version to a known supported image.
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'image_version': ('latest' if operator_version == 'master' else operator_version) if supported_kiali_images[kiali_vars.version].image_version == 'operator_version' else supported_kiali_images[kiali_vars.version].image_version}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.image_version == ""

- name: If image version is latest then we will want to always pull
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'image_pull_policy': 'Always'}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.image_version == "latest"

- name: Set default auth strategy based on cluster type
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'auth': {'strategy': 'openshift' if is_openshift else 'token'}}, recursive=True) }}"
  when:
  - kiali_vars.auth.strategy == ""

- name: Use OpenShift service CA file for Grafana
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'grafana': {'auth': {'ca_file': '/kiali-cabundle/service-ca.crt'}}}}, recursive=True) }}"
  when:
  - is_openshift == True
  - kiali_vars.external_services.grafana.auth.ca_file is not defined or kiali_vars.external_services.grafana.auth.ca_file == ''

- name: Use OpenShift service CA file for Prometheus
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'prometheus': {'auth': {'ca_file': '/kiali-cabundle/service-ca.crt'}}}}, recursive=True) }}"
  when:
  - is_openshift == True
  - kiali_vars.external_services.prometheus.auth.ca_file is not defined or kiali_vars.external_services.prometheus.auth.ca_file == ''

- name: Use OpenShift service CA file for Tracing
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'external_services': {'tracing': {'auth': {'ca_file': '/kiali-cabundle/service-ca.crt'}}}}, recursive=True) }}"
  when:
  - is_openshift == True
  - kiali_vars.external_services.tracing.auth.ca_file is not defined or kiali_vars.external_services.tracing.auth.ca_file == ''

# Indicate how users are to authenticate to Kiali, making sure the strategy is valid.
- debug:
    msg: "AUTH STRATEGY={{ kiali_vars.auth.strategy }}"
- name: Confirm auth strategy is valid for OpenShift environments
  fail:
    msg: "Invalid auth.strategy [{{ kiali_vars.auth.strategy }}]! Must be one of either 'openshift', 'token' or 'anonymous'"
  when:
  - is_openshift == True
  - kiali_vars.auth.strategy != 'anonymous'
  - kiali_vars.auth.strategy != 'openshift'
  - kiali_vars.auth.strategy != 'token'
- name: Confirm auth strategy is valid for Kubernetes environments
  fail:
    msg: "Invalid auth.strategy [{{ kiali_vars.auth.strategy }}]! Must be one of either 'token', 'openid' or 'anonymous'"
  when:
  - is_k8s == True
  - kiali_vars.auth.strategy != 'anonymous'
  - kiali_vars.auth.strategy != 'token'
  - kiali_vars.auth.strategy != 'openid'
- name: Confirm OpenID configuration when auth strategy is 'openid'
  fail:
    msg: "Invalid configuration for OpenID connect! The mandatory parameters should be provided: 'issuer_uri', 'client_id'. Also, the 'username_claim' cannot be set to the empty string."
  when:
  - kiali_vars.auth.strategy == "openid"
  - kiali_vars.auth.openid.issuer_uri == "" or kiali_vars.auth.openid.client_id == "" or kiali_vars.auth.openid.username_claim == ""
# Fail if ingress is disabled but auth_strategy is openshift. This is because the openshift auth strategy
# requires OAuth Client which requires a Route. So ingress must be enabled if strategy is openshift.
- name: Ensure Ingress is Enabled if Auth Strategy is openshift
  fail:
    msg: "The auth.strategy is 'openshift' which requires a Route, but deployment.ingress_enabled is false. Aborting."
  when:
  - kiali_vars.auth.strategy == "openshift"
  - kiali_vars.deployment.ingress_enabled|bool == False

- name: Confirm the cluster can access github.com when it needs to determine the last release of Kiali
  uri:
    url: https://api.github.com/repos/kiali/kiali-operator/releases
  when:
  - kiali_vars.deployment.image_version == "lastrelease"
- name: Determine image version when last release is to be installed
  shell: echo -n $(curl -s https://api.github.com/repos/kiali/kiali-operator/releases 2> /dev/null | grep "tag_name" | sed -e 's/.*://' -e 's/ *"//' -e 's/",//' | grep -v "snapshot" | sort -t "." -k 1.2g,1 -k 2g,2 -k 3g | tail -n 1)
  register: github_lastrelease
  when:
  - kiali_vars.deployment.image_version == "lastrelease"
- set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'image_version': github_lastrelease.stdout}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.image_version == "lastrelease"

- name: Determine image version when it explicitly was configured as the operator_version
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'image_version': 'latest' if operator_version == 'master' else operator_version}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.image_version == "operator_version"

- fail:
    msg: "Could not determine what the image version should be. Set deployment.image_version to a valid value"
  when:
  - kiali_vars.deployment.image_version == "" or kiali_vars.deployment.image_version == "unknown"

- name: Determine version_label based on image_version
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'version_label': 'master' if kiali_vars.deployment.image_version == 'latest' else kiali_vars.deployment.image_version}}, recursive=True) }}"
  when:
  - kiali_vars.deployment.version_label == ""

# Kubernetes limits the length of version label strings to 63 characters or less - make sure the label is valid.
- name: Trim version_label when appropriate
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'version_label': kiali_vars.deployment.version_label[:60] + 'XXX' }}, recursive=True) }}"
  when:
  - kiali_vars.deployment.version_label | length > 63

# Indicate which Kiali image we are going to use.
- debug:
    msg: "IMAGE_NAME={{ kiali_vars.deployment.image_name }}; IMAGE VERSION={{ kiali_vars.deployment.image_version }}; VERSION LABEL={{ kiali_vars.deployment.version_label }}"

# Determine the accessible namespaces. The user may have specified names using regex expressions.
# We need to get a list of all namespaces and match them to the regex expressions.
# Note that we replace kiali_vars.deployment.accessible_namespaces with the full list of actual namespace names
# with regex expressions removed because when the CR changes, we need to know what namespaces were granted roles in
# case we need to revoke those roles (to do this, we need to know the exact names of the namespaces).
# This must be done before the next step which is figuring out what namespaces are no longer accessible and revoking their roles.
# If the user did not specify Kiali's own namespace in accessible_namespaces, it will be added to the list automatically.
# NOTE: there is a special value of accessible_namespaces - two asterisks ("**") means Kiali is to be given access to all
# namespaces via a single cluster role (as opposed to individual roles in each accessible namespace).

- name: Determine the Role and RoleBinding kinds that the operator will create and that the role templates will use
  set_fact:
    role_kind: "{{ 'ClusterRole' if '**' in kiali_vars.deployment.accessible_namespaces else 'Role' }}"
    role_binding_kind: "{{ 'ClusterRoleBinding' if '**' in kiali_vars.deployment.accessible_namespaces else 'RoleBinding' }}"

- name: Find all namespaces (this is limited to what the operator has permission to see)
  set_fact:
    all_namespaces: "{{ lookup('k8s', api_version='v1', kind='Namespace') | default({}) | json_query('[].metadata.name') }}"
  when:
  - '"**" not in kiali_vars.deployment.accessible_namespaces'

- name: Determine all accessible namespaces, expanding regex expressions to matched namespaces
  set_fact:
    all_accessible_namespaces: "{{ (all_namespaces | only_accessible_namespaces(accessible_namespaces=kiali_vars.deployment.accessible_namespaces) + [ kiali_vars.deployment.namespace, kiali_vars.istio_namespace ]) | unique | sort }}"
  when:
  - '"**" not in kiali_vars.deployment.accessible_namespaces'

- name: If accessible namespaces list has the special all-namespaces indicator, remove all other namespaces from the list
  set_fact:
    all_accessible_namespaces: ["**"]
  when:
  - '"**" in kiali_vars.deployment.accessible_namespaces'

- name: Set deployment.accessible_namespaces to a list of full namespace names
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'deployment': {'accessible_namespaces': all_accessible_namespaces }}, recursive=True) }}"

- name: Listing of all accessible namespaces (includes regex matches)
  debug:
    msg: "{{ kiali_vars.deployment.accessible_namespaces }}"

- name: When accessible namespaces are specified, ensure label selector is set
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'api': {'namespaces': {'label_selector': ('kiali.io/member-of=' + kiali_vars.deployment.namespace)}}}, recursive=True) }}"
  when:
  - '"**" not in kiali_vars.deployment.accessible_namespaces'
  - kiali_vars.api.namespaces.label_selector is not defined

- name: Make sure label selector is in the valid format name=value
  fail:
    msg: "The api.namespaces.label_selector is not valid [{{ kiali_vars.api.namespaces.label_selector }}] - it must be in the form of 'name=value' following Kubernetes syntax rules for label names and values."
  when:
  - kiali_vars.api.namespaces.label_selector is defined
  # this regex is not 100% accurate, but we want to at least catch obvious errors
  - kiali_vars.api.namespaces.label_selector is not regex('^[a-zA-Z0-9/_.-]+=[a-zA-Z0-9_.-]+$')

# If the signing key is empty string, we need to ensure a signing key secret exists - if it does not generate one.

- name: Get information about any existing signing key secret if we need to know if it exists or not
  community.kubernetes.k8s_info:
    api_version: v1
    kind: Secret
    namespace: "{{ kiali_vars.deployment.namespace }}"
    name: kiali-signing-key
  register: signing_key_secret_raw
  when:
  - kiali_vars.login_token.signing_key == ""

- name: Create secret to store a random signing key if a secret does not already exist and we need one
  k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        namespace: "{{ kiali_vars.deployment.namespace }}"
        name: kiali-signing-key
        labels:
          app: kiali
          version: "{{ kiali_vars.deployment.version_label }}"
      type: Opaque
      data:
        key: "{{ lookup('password', '/dev/null length=16 chars=ascii_letters,digits') | b64encode }}"
  when:
  - kiali_vars.login_token.signing_key == ""
  - signing_key_secret_raw is defined
  - signing_key_secret_raw.resources is defined
  - signing_key_secret_raw.resources | length == 0

- name: Point signing key to the generated secret
  set_fact:
    kiali_vars: "{{ kiali_vars | combine({'login_token': {'signing_key': 'secret:kiali-signing-key:key'}}, recursive=True) }}"
  when:
  - kiali_vars.login_token.signing_key == ""

# Prepare any additional environment variables that need to be defined in the deployment

- set_fact:
    kiali_deployment_environment_variables: {}

- name: Prepare environment variable for prometheus password
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'PROMETHEUS_PASSWORD': {'secret_name': kiali_vars.external_services.prometheus.auth.password | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.prometheus.auth.password | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.prometheus.auth.password | regex_search('secret:.+:.+')

- name: Prepare environment variable for prometheus token
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'PROMETHEUS_TOKEN': {'secret_name': kiali_vars.external_services.prometheus.auth.token | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.prometheus.auth.token | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.prometheus.auth.token | regex_search('secret:.+:.+')

- name: Prepare environment variable for tracing password
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'TRACING_PASSWORD': {'secret_name': kiali_vars.external_services.tracing.auth.password | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.tracing.auth.password | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.tracing.auth.password | regex_search('secret:.+:.+')

- name: Prepare environment variable for tracing token
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'TRACING_TOKEN': {'secret_name': kiali_vars.external_services.tracing.auth.token | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.tracing.auth.token | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.tracing.auth.token | regex_search('secret:.+:.+')

- name: Prepare environment variable for grafana password
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'GRAFANA_PASSWORD': {'secret_name': kiali_vars.external_services.grafana.auth.password | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.grafana.auth.password | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.grafana.auth.password | regex_search('secret:.+:.+')

- name: Prepare environment variable for grafana token
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'GRAFANA_TOKEN': {'secret_name': kiali_vars.external_services.grafana.auth.token | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.external_services.grafana.auth.token | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.external_services.grafana.auth.token | regex_search('secret:.+:.+')

- name: Prepare environment variable for login token signing key
  set_fact:
    kiali_deployment_environment_variables: "{{ kiali_deployment_environment_variables | combine({'LOGIN_TOKEN_SIGNING_KEY': {'secret_name': kiali_vars.login_token.signing_key | regex_replace('secret:(.+):.+', '\\1'), 'secret_key': kiali_vars.login_token.signing_key | regex_replace('secret:.+:(.+)', '\\1') }}) }}"
  when:
  - kiali_vars.login_token.signing_key | regex_search('secret:.+:.+')

# The following few tasks read the current Kiali configmap (if one exists) in order to figure out what
# namespaces are no longer accessible. Those namespaces will have their Kiali roles removed.
# They will also have the Kiali labels removed.

- name: Find current configmap, if it exists
  set_fact:
    current_configmap: "{{ lookup('k8s', resource_name='kiali', namespace=kiali_vars.deployment.namespace, api_version='v1', kind='ConfigMap') }}"

- name: Find some current configuration settings
  set_fact:
    current_accessible_namespaces: "{{ current_configmap.data['config.yaml'] | from_yaml | json_query('deployment.accessible_namespaces') }}"
    current_label_selector: "{{ current_configmap.data['config.yaml'] | from_yaml | json_query('api.namespaces.label_selector') }}"
    current_view_only_mode: "{{ current_configmap.data['config.yaml'] | from_yaml | json_query('deployment.view_only_mode') }}"
    current_image_name: "{{ current_configmap.data['config.yaml'] | from_yaml | json_query('deployment.image_name') }}"
    current_image_version: "{{ current_configmap.data['config.yaml'] | from_yaml | json_query('deployment.image_version') }}"
  when:
  - current_configmap is defined
  - current_configmap.data is defined
  - current_configmap.data['config.yaml'] is defined

# Because we need to remove the labels that were created before, we must not allow the user to change
# the label_selector. So if the current accessible_namespaces is not ** but the label_select is being changed,
# we need to abort since we won't know what the old labels were. If current accessible_namespaces is ** then
# we know we didn't create labels before so we can allow label_selector to change.
- name: Do not allow user to change label selector
  fail:
    msg: "The api.namespaces.label_selector cannot be changed to a different value. It was [{{ current_label_selector }}] but is now configured to be [{{ kiali_vars.api.namespaces.label_selector }}]. In order to install Kiali with a different label selector than what was used before, please uninstall Kiali first."
  when:
  - current_accessible_namespaces is defined
  - '"**" not in current_accessible_namespaces'
  - current_label_selector is defined
  - kiali_vars.api.namespaces.label_selector is defined
  - current_label_selector != kiali_vars.api.namespaces.label_selector

- name: Determine the namespaces that were previously accessible but are now inaccessible
  set_fact:
    no_longer_accessible_namespaces: "{{ current_accessible_namespaces | difference(kiali_vars.deployment.accessible_namespaces) }}"
  when:
  - current_accessible_namespaces is defined
  - '"**" not in current_accessible_namespaces'

- name: Delete all additional Kiali roles from namespaces that Kiali no longer has access to
  include_tasks: remove-roles.yml
  loop: "{{ no_longer_accessible_namespaces }}"
  loop_control:
    loop_var: role_namespace
  when:
  - no_longer_accessible_namespaces is defined

- name: Delete Kiali cluster roles if no longer given special access to all namespaces
  include_tasks: remove-clusterroles.yml
  when:
  - current_accessible_namespaces is defined
  - '"**" in current_accessible_namespaces'
  - '"**" not in kiali_vars.deployment.accessible_namespaces'

- name: Delete all Kiali roles from namespaces if view_only_mode is changing since role bindings are immutable
  include_tasks: remove-roles.yml
  loop: "{{ kiali_vars.deployment.accessible_namespaces }}"
  loop_control:
    loop_var: role_namespace
  when:
  - current_view_only_mode is defined
  - current_view_only_mode|bool != kiali_vars.deployment.view_only_mode|bool
  - current_accessible_namespaces is defined
  - '"**" not in current_accessible_namespaces'

- name: Delete Kiali cluster roles if view_only_mode is changing since role bindings are immutable
  include_tasks: remove-clusterroles.yml
  when:
  - current_view_only_mode is defined
  - current_view_only_mode|bool != kiali_vars.deployment.view_only_mode|bool
  - current_accessible_namespaces is defined
  - '"**" in current_accessible_namespaces'

- name: Remove Kiali label from namespaces that Kiali no longer has access to
  include_tasks: remove-namespace-label.yml
  vars:
    the_namespace_label_name: "{{ current_label_selector | regex_replace('^(.*)=.*$', '\\1') }}"
  loop: "{{ no_longer_accessible_namespaces }}"
  loop_control:
    loop_var: the_namespace
  when:
  - no_longer_accessible_namespaces is defined
  - current_label_selector is defined

- name: Create namespace labels on all accessible namespaces
  include_tasks: create-namespace-label.yml
  vars:
    # everything to the left of the = is the label name; to the right is the label value
    the_namespace_label_name: "{{ kiali_vars.api.namespaces.label_selector | regex_replace('^(.*)=.*$', '\\1') }}"
    the_namespace_label_value: "{{ kiali_vars.api.namespaces.label_selector | regex_replace('^.*=(.*)$', '\\1') }}"
  loop: "{{ kiali_vars.deployment.accessible_namespaces }}"
  loop_control:
    loop_var: the_namespace
  when:
  - '"**" not in kiali_vars.deployment.accessible_namespaces'

- name: Delete Kiali deployment if image is changing - this uninstalled any old version of Kiali that might be running
  k8s:
    state: absent
    api_version: apps/v1
    kind: Deployment
    namespace: "{{ kiali_vars.deployment.namespace }}"
    name: kiali
  when:
  - is_openshift == True or is_k8s == True
  - current_image_name is defined and current_image_version is defined
  - (current_image_name != kiali_vars.deployment.image_name) or (current_image_version != kiali_vars.deployment.image_version)

# Get the deployment's custom annotation we set that tells us when we last updated the Deployment.
# We need this to ensure the Deployment we update retains this same timestamp unless changes are made
# that requires a pod restart - in which case we update this timestamp.
- name: Find current deployment, if it exists
  set_fact:
    current_deployment: "{{ lookup('k8s', resource_name='kiali', namespace=kiali_vars.deployment.namespace, api_version='apps/v1', kind='Deployment') }}"

- name: Get current deployment last-updated annotation timestamp from existing deployment
  set_fact:
    current_deployment_last_updated: "{{ current_deployment.spec.template.metadata.annotations['operator.kiali.io/last-updated'] if current_deployment.spec.template.metadata.annotations['operator.kiali.io/last-updated'] is defined else lookup('pipe','date') }}"
    deployment_is_new: false
  when:
  - current_deployment is defined
  - current_deployment.spec is defined
  - current_deployment.spec.template is defined
  - current_deployment.spec.template.metadata is defined
  - current_deployment.spec.template.metadata.annotations is defined

- name: Set current deployment last-updated annotation timestamp for new deployments
  set_fact:
    current_deployment_last_updated: "{{ lookup('pipe','date') }}"
    deployment_is_new: true
  when:
  - current_deployment_last_updated is not defined

# Now deploy all resources for the specific cluster environment

- name: Execute for OpenShift environment
  include: openshift/os-main.yml
  vars:
    deployment_last_updated: "{{ current_deployment_last_updated }}"
  when:
  - is_openshift == True

- name: Execute for Kubernetes environment
  include: kubernetes/k8s-main.yml
  vars:
    deployment_last_updated: "{{ current_deployment_last_updated }}"
  when:
  - is_k8s == True

# The next few tasks wait for the Monitoring Dashboard CRD to be established, and
# then adds the monitoring dashboard resources. If there are any errors here, they
# are ignored - since the monitoring dashboards are optional, we allow the install to
# continue even though it means the monitoring dashboards feature will be disabled.
# If the dashboards are disabled, we still quickly check to make sure the CRD exists
# because we may need to remove dashboards that were created previously.

- name: Wait for Monitoring Dashboards CRD to be ready
  community.kubernetes.k8s_info:
    api_version: apiextensions.k8s.io/v1beta1
    kind: CustomResourceDefinition
    name: monitoringdashboards.monitoring.kiali.io
  register: monitoringdashboards_crd
  until:
  - monitoringdashboards_crd.resources is defined
  - monitoringdashboards_crd | json_query('resources[*].status.conditions[?type==`Established`].status') | flatten | join == 'True'
  retries: "{{ 6 if kiali_vars.external_services.custom_dashboards.enabled == True else 1 }}"
  delay: 5
  ignore_errors: yes

- name: Check if the Monitoring Dashboards CRD exists and is ready
  set_fact:
    monitoringdashboards_crd_exists: "{{ (monitoringdashboards_crd.resources is defined) and (monitoringdashboards_crd | json_query('resources[*].status.conditions[?type==`Established`].status') | flatten | join == 'True') }}"

- name: Warn if Monitoring Dashboards CRD is not available
  debug:
    msg: "It does not appear you have the Monitoring Dashboard CRD created. Monitoring Dashboards will not be created."
  when:
  - kiali_vars.external_services.custom_dashboards.enabled == True
  - monitoringdashboards_crd_exists == False

- name: Find all Monitoring Dashboards packaged with the operator
  find:
    paths: "{{ role_path }}/templates/dashboards"
  register: monitoring_dashboard_yamls_all_raw
  when:
  - monitoringdashboards_crd_exists == True
  ignore_errors: yes

- set_fact:
    monitoring_dashboard_yamls_all: "{{ (monitoring_dashboard_yamls_all | default([])) + [ item.path ] }}"
  loop: "{{ monitoring_dashboard_yamls_all_raw.files }}"
  when:
  - monitoringdashboards_crd_exists == True
  - monitoring_dashboard_yamls_all_raw is defined
  - monitoring_dashboard_yamls_all_raw.files is defined

- name: Determine which Monitoring Dashboards are to be created
  find:
    paths: "{{ role_path }}/templates/dashboards"
    patterns: "{{ kiali_vars.deployment.custom_dashboards.includes }}"
    excludes: "{{ kiali_vars.deployment.custom_dashboards.excludes }}"
  register: monitoring_dashboard_yamls_to_deploy_raw
  when:
  - kiali_vars.external_services.custom_dashboards.enabled == True
  - monitoringdashboards_crd_exists == True
  ignore_errors: yes

- set_fact:
    monitoring_dashboard_yamls_to_deploy: "{{ (monitoring_dashboard_yamls_to_deploy | default([])) + [ item.path ] }}"
  loop: "{{ monitoring_dashboard_yamls_to_deploy_raw.files }}"
  when:
  - kiali_vars.external_services.custom_dashboards.enabled == True
  - monitoringdashboards_crd_exists == True
  - monitoring_dashboard_yamls_to_deploy_raw is defined
  - monitoring_dashboard_yamls_to_deploy_raw.files is defined

- name: If monitoring dashboards are disabled, indicate no dashboards are to be deployed
  set_fact:
    monitoring_dashboard_yamls_to_deploy: []
  when:
  - (kiali_vars.external_services.custom_dashboards.enabled == False) or (monitoringdashboards_crd_exists == False)

- name: Determine what monitoring dashboards should be removed
  set_fact:
    monitoring_dashboard_yamls_to_remove: "{{ (monitoring_dashboard_yamls_all | default([])) | difference(monitoring_dashboard_yamls_to_deploy | default([])) }}"
  when:
  - monitoringdashboards_crd_exists == True

- name: Remove Monitoring Dashboards that should no longer be deployed
  k8s:
    state: "absent"
    namespace: "{{ kiali_vars.deployment.namespace }}"
    definition: |
      {% for mdy in monitoring_dashboard_yamls_to_remove %}
      ---
      {{ lookup("template", mdy) }}
      ...
      {% endfor %}
  when:
  - monitoringdashboards_crd_exists == True
  - monitoring_dashboard_yamls_to_remove is defined
  - monitoring_dashboard_yamls_to_remove | length > 0
  ignore_errors: yes

- name: Create the Monitoring Dashboards
  k8s:
    state: "present"
    namespace: "{{ kiali_vars.deployment.namespace }}"
    definition: |
      {% for mdy in monitoring_dashboard_yamls_to_deploy %}
      ---
      {{ lookup("template", mdy) }}
      ...
      {% endfor %}
  when:
  - monitoringdashboards_crd_exists == True
  - monitoring_dashboard_yamls_to_deploy is defined
  - monitoring_dashboard_yamls_to_deploy | length > 0
  ignore_errors: yes

# If something changed that can only be picked up when the Kiali pod starts up, then restart the Kiali pod using a rolling restart

- name: Force the Kiali pod to restart if necessary
  vars:
    updated_deployment: "{{ lookup('k8s', resource_name='kiali', namespace=kiali_vars.deployment.namespace, api_version='apps/v1', kind='Deployment') | combine({'spec': {'template': {'metadata': {'annotations': {'operator.kiali.io/last-updated': lookup('pipe','date') }}}}}, recursive=True) }}"
  k8s:
    state: "present"
    definition: "{{ updated_deployment }}"
  when:
  - deployment_is_new == False
  - processed_resources.configmap is defined
  - processed_resources.configmap.changed == True
  - processed_resources.configmap.method == "patch"

# Can't just populate with the list of namespaces - see https://github.com/operator-framework/operator-sdk-ansible-util/issues/12
# So instead - if the list of namespaces is manageable, store them in a comma-separate list.
# Otherwise, we'll just log the count. The purpose of this accessibleNamespaces status field is
# just to inform the user how many namespaces the operator processed.
- include_tasks: update-status.yml
  vars:
    status_vars:
      accessibleNamespaces: "{{ ('Number of accessible namespaces (including control plane namespace): ' + (kiali_vars.deployment.accessible_namespaces | length | string)) if (kiali_vars.deployment.accessible_namespaces | length > 20) else (kiali_vars.deployment.accessible_namespaces | join(',')) }}"
